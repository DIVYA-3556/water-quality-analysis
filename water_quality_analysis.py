# -*- coding: utf-8 -*-
"""water quality analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11lIs_O5hfTNFDPMgR4nsOnYJyMPFCO-L
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""**Reasoning**:
Load the data from the provided CSV file into a pandas DataFrame and display the first few rows to verify.


"""

import pandas as pd

try:
    df = pd.read_csv('waterQuality1.csv')
    display(df.head())
except FileNotFoundError:
    print("Error: 'waterQuality1.csv' not found.")
    df = None  # Set df to None to indicate failure
except pd.errors.ParserError:
    print("Error: Could not parse the CSV file. Check its format.")
    df = None
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    df = None

# Examine the 'ammonia' column for unique values
print(df['ammonia'].unique())

# Further investigate 'is_safe' column
print(df['is_safe'].unique())

# Try to convert ammonia again, replacing non-numeric values with NaN.
# Then, check for missing values.
df['ammonia'] = pd.to_numeric(df['ammonia'], errors='coerce')
print(df.isnull().sum())

#Initial Observations
print("\nInitial Observations:")
print("1. Data Shape: The dataset has", df.shape[0], "rows and", df.shape[1], "columns.")
print("2. Data Types: Most columns are numeric, but 'ammonia' and 'is_safe' initially appeared to be objects. The 'ammonia' column will be further investigated and cleaned.")
print("3. Missing Values: After the conversion, there are missing values in the 'ammonia' column. Further investigation is needed to determine the best way to handle these missing values.")
print("4. Unique Values: The number of unique values for each column varies. The 'is_safe' column might represent a binary classification, but requires further investigation due to the data type.")
print("5. Distributions:  The histograms can provide insights into the distributions of the numerical features after the data cleaning steps.")
print("6. Correlation Analysis: The correlation analysis and the heatmap will be performed after the data cleaning.")
print("7. Potential Issues:  The 'ammonia' column and 'is_safe' column require additional cleaning to handle non-numeric and potentially inconsistent values.  The initial histograms and correlation analysis need to be repeated after data cleaning.")

# Handle '#NUM!' in 'is_safe'
df['is_safe'] = df['is_safe'].replace('#NUM!', float('nan'))
df['is_safe'] = pd.to_numeric(df['is_safe'], errors='coerce')

# Impute missing values in 'ammonia' with the mean
df['ammonia'].fillna(df['ammonia'].mean(), inplace=True)

# Recalculate the correlation matrix
correlation_matrix = df.corr()

plt.figure(figsize=(16, 12))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title("Correlation Matrix Heatmap")
plt.show()

# Initial Observations
print("\nInitial Observations:")
print("1. Data Shape: The dataset has", df.shape[0], "rows and", df.shape[1], "columns.")
print("2. Data Types: 'ammonia' and 'is_safe' columns are now numeric.")
print("3. Missing Values: Missing values in 'ammonia' have been imputed with the mean. Missing values in 'is_safe' remain.")
print("4. Unique Values: The number of unique values for each column provides information about the variability in the data.")
print("5. Distributions: The histograms help to visualize the distributions of the numerical features.")
print("6. Correlation Analysis: The heatmap shows the correlation coefficients between pairs of numerical features.")
print("7. Potential Issues: There are still missing values in 'is_safe'.  Further analysis and potential imputation or removal of those rows might be needed.")

import pandas as pd
import numpy as np

# Impute missing values in 'is_safe' with the mode
df['is_safe'].fillna(df['is_safe'].mode()[0], inplace=True)

# Outlier detection and handling using IQR
for col in df.select_dtypes(include=np.number).columns:
    if col != 'is_safe':  # Exclude the 'is_safe' column from outlier analysis
        Q1 = df[col].quantile(0.25)
        Q3 = df[col].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        df[col] = np.clip(df[col], lower_bound, upper_bound)

# Verify data quality after cleaning
print(df.isnull().sum())
print(df.describe())

display(df.head())

import pandas as pd
import numpy as np

# Impute missing values in 'is_safe' with the mode
df['is_safe'] = df['is_safe'].fillna(df['is_safe'].mode()[0])

# Outlier detection and handling using IQR
for col in df.select_dtypes(include=np.number).columns:
    if col != 'is_safe':  # Exclude the 'is_safe' column from outlier analysis
        Q1 = df[col].quantile(0.25)
        Q3 = df[col].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        df[col] = np.clip(df[col], lower_bound, upper_bound)

# Verify data quality after cleaning
print(df.isnull().sum())
print(df.describe())
display(df.head())

import pandas as pd
import numpy as np

# Data Loading and Cleaning Process
#
# 1. Data Loading: The initial data was loaded from 'waterQuality1.csv' into a pandas DataFrame.
# 2. Data Exploration: Exploratory data analysis revealed non-numeric values in the 'ammonia' and 'is_safe' columns.
# 3. Data Cleaning:
#    - Missing values in 'ammonia' were imputed using the mean.
#    - '#NUM!' values in 'is_safe' were handled by converting them to NaN and then imputing with the mode.
#    - Outliers in numerical features (excluding 'is_safe') were capped using the IQR method.
#    - All missing values in the 'is_safe' column were filled with the mode.
# 4. Data Type Conversion: The 'is_safe' column was converted to numeric type.

# Load the cleaned DataFrame
try:
    df = pd.read_csv('waterQuality1.csv')

    # Apply the same cleaning steps as before
    df['ammonia'] = pd.to_numeric(df['ammonia'], errors='coerce')
    df['ammonia'].fillna(df['ammonia'].mean(), inplace=True)
    df['is_safe'] = df['is_safe'].replace('#NUM!', float('nan'))
    df['is_safe'] = pd.to_numeric(df['is_safe'], errors='coerce')
    df['is_safe'] = df['is_safe'].fillna(df['is_safe'].mode()[0])

    for col in df.select_dtypes(include=np.number).columns:
        if col != 'is_safe':
            Q1 = df[col].quantile(0.25)
            Q3 = df[col].quantile(0.75)
            IQR = Q3 - Q1
            lower_bound = Q1 - 1.5 * IQR
            upper_bound = Q3 + 1.5 * IQR
            df[col] = np.clip(df[col], lower_bound, upper_bound)

    #Optional: Save the cleaned DataFrame to a new CSV file
    df.to_csv('water_quality_cleaned.csv', index=False)

    display(df.head())
except FileNotFoundError:
    print("Error: 'waterQuality1.csv' not found.")
except Exception as e:
    print(f"An unexpected error occurred: {e}")

import pandas as pd
import numpy as np

# Data Loading and Cleaning Process
#
# 1. Data Loading: The initial data was loaded from 'waterQuality1.csv' into a pandas DataFrame.
# 2. Data Exploration: Exploratory data analysis revealed non-numeric values in the 'ammonia' and 'is_safe' columns.
# 3. Data Cleaning:
#    - Missing values in 'ammonia' were imputed using the mean.
#    - '#NUM!' values in 'is_safe' were handled by converting them to NaN and then imputing with the mode.
#    - Outliers in numerical features (excluding 'is_safe') were capped using the IQR method.
#    - All missing values in the 'is_safe' column were filled with the mode.
# 4. Data Type Conversion: The 'is_safe' column was converted to numeric type.

# Load the cleaned DataFrame
try:
    df = pd.read_csv('waterQuality1.csv')

    # Apply the same cleaning steps as before
    df['ammonia'] = pd.to_numeric(df['ammonia'], errors='coerce')
    df['ammonia'] = df['ammonia'].fillna(df['ammonia'].mean())
    df['is_safe'] = df['is_safe'].replace('#NUM!', float('nan'))
    df['is_safe'] = pd.to_numeric(df['is_safe'], errors='coerce')
    df['is_safe'] = df['is_safe'].fillna(df['is_safe'].mode()[0])

    for col in df.select_dtypes(include=np.number).columns:
        if col != 'is_safe':
            Q1 = df[col].quantile(0.25)
            Q3 = df[col].quantile(0.75)
            IQR = Q3 - Q1
            lower_bound = Q1 - 1.5 * IQR
            upper_bound = Q3 + 1.5 * IQR
            df[col] = np.clip(df[col], lower_bound, upper_bound)

    #Optional: Save the cleaned DataFrame to a new CSV file
    df.to_csv('water_quality_cleaned.csv', index=False)

    display(df.head())
except FileNotFoundError:
    print("Error: 'waterQuality1.csv' not found.")
except Exception as e:
    print(f"An unexpected error occurred: {e}")

df.tail()

df.shape

df.columns

df.info()

df.duplicated()

df.duplicated().sum()

num_cols = ['ammonia', 'is_safe']

plt.figure(figsize=(12, 6))
sns.boxplot(data=df[num_cols])
plt.title('Box Plot of Numerical Columns')
plt.xticks(rotation=45)
plt.show()

df['Water_Quality'] = 'Safe'
df.loc[(df['bacteria'] > 1.0) | (df['arsenic'] > 0.01) | (df['lead'] > 0.015), 'Water_Quality'] = 'Unsafe'

import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('waterQuality1.csv')

df['Water_Quality'] = df.apply(lambda row: 'Unsafe' if (row['bacteria'] > 1.0) or (row['arsenic'] > 0.01) or (row['lead'] > 0.015) else 'Safe', axis=1)

df['Water_Quality'].value_counts().plot.pie(autopct='%1.1f%%', colors=['skyblue', 'salmon'], figsize=(6,6), title='Water Quality')
plt.ylabel('')
plt.show()

df .to_pickle('waterQuality1.pkl')
print("Saved as Pickle file successfully!")

import pandas as pd

# Load CSV
df = pd.read_csv('waterQuality1.csv')

# Save as Pickle
df.to_pickle('waterQuality1.pkl')

# Save as CSV
df.to_csv('waterQuality1_saved.csv', index=False)

!pip install streamlit